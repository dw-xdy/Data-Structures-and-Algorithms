package class042;

import java.util.List;

/**
 * @author 冯肖伟
 * @version 1.0
 */
public class My_Code01_AppleMinBags {

    public static int bags(int n) {
        int ans = f(n);
        return ans == Integer.MAX_VALUE ? -1 : ans;
    }

    // 这个递归函数的意义是：将苹果对应的需要的袋子的数量返回, 但是利用的是最暴力的方式
//    public static int f(int n) {
//        if (n < 0) {
//            return Integer.MAX_VALUE;
//        }
//        if (n == 0) {
//            return 0;
//        }
//
//        // 此时我们使用了一个规格为 8 的袋子, 那么接下来将剩下的所有苹果需要几个袋子返回给 p1.
//        int p1 = f(n - 8);
//        // 此时我们使用了一个规格为 6 的袋子, 那么接下来将剩下的所有苹果需要几个袋子返回给 p2.
//        int p2 = f(n - 6);
//
//        // 若是 p1 不是无效值, 那么我们此时应该加上自己这8个用过的这一个袋子.
//        // 因为都返回了一个有效值了, 说明剩下的苹果肯定是能用某种方式装满, 我们刚刚减去了8, 所以我们
//        // 还需要用一个袋子装满这个8.
//        p1 += p1 == Integer.MAX_VALUE ? 0 : 1;
//        // 若是 p2 不是无效值, 那么我们此时应该加上自己这6个用过的这一个袋子.
//        p2 += p2 == Integer.MAX_VALUE ? 0 : 1;
//
//        // 最后返回的值是先用8个的袋子装还是先用6个袋子的装.
//        return Math.min(p1, p2);
//    }


    // 我们先来写一下下面这个递归函数的思路
    // 首先：我们要明确这个函数的意义(返回值)：求输入的苹果能用几个袋子正好装好(几个袋子).
    // 那么我们假设此时有 x 个苹果, 那么首先我们用 8 个袋子装, 那么就剩下了 x - 8 个苹果,
    // 所以我们用 f(x - 8), 这个函数的返回值有两种情况, 一种是一个有效值：0, 1, 2, 3..., 另一种是：无效值.
    // 那么这个“无效值”怎么表示呢? 我们干脆用无穷大表示：Integer.MAX_VALUE.
    // 若是返回了一个有效值, 还要加上我们自己的这个 8 , 所以需要 + 1.
    // 若是返回了一个无效值, 就直接保持无效值就行了, 因为这个无效值本身就是没有意义的.
    // 然后我们用 6 个袋子装, 那么就剩下了 x - 6, 还是和上面的一样的方式.
    // 这样执行下来, 最后肯定有两个答案, 因为我们要的是尽量少的袋子, 我们只需要最小的那个.
    // 那么此时就有一个问题, 无效值怎么表示, 而且在什么样的情况下会返回一个无效值.
    // 要是 x < 0, 那么肯定是一个无效值, 因为苹果的数量是不可能小于 0 的.
    // 若是 x == 0, 那么这是一个有效值, 因为我用 0 个袋子就能装好.
    // x == 0 的情况确实有点不好想象, 可以结合实际情况, 比如带入几个实例：8, 6, 14 等特殊值.
    // 若是 x == 8, 那么通过这个函数, 下一步就是：f(0), 若是我返回Integer.MAX_VALUE(无效值), 那么最后结果就无效
    // 因为返回一个无效值, 所以最后的结果也是一个无效值.但是我们想象一下, 8 个苹果肯定是返回 1 , 那么肯定应该返回一个有效值,
    // 结合我们上面的一般情况, 最后结果是 1, 应该返回一个：有效值 + 1 == 1, 所以有效值为：0,
    // 所以这样就能确定 x == 0 的情况下, 返回的结果应该是 0 .

    public static int f(int apple) {
        if (apple < 0) {
            return Integer.MAX_VALUE;
        }
        if (apple == 0) {
            return 0;
        }
        int p1 = f(apple - 8);
//        if (p1 != Integer.MAX_VALUE) {
//            p1 += 1;
//        }
        p1 += p1 == Integer.MAX_VALUE ? 0 : 1;
        int p2 = f(apple - 6);
//        if (p2 != Integer.MAX_VALUE) {
//            p2 += 1;
//        }
        p2 += p2 == Integer.MAX_VALUE ? 0 : 1;
        return Math.min(p1, p2);
    }

    public static void main(String[] args) {
        for (int i = 0; i <= 50; i++) {
            System.out.println("apple数量为：" + i + " 对应的袋子为：" + bags(i));
        }
    }






}
